{"posts":[{"title":"Node.js 浅析","text":"什么是 Node.js官方定义 Node.js 是一个开源的，跨平台的 Javascript 运行时环境。 要理解这个定义需要从 Javascript 的前身谈起。在 2009 年 Node.js 出现之前，Javascript 只能运行在浏览器中，作为网页脚本使用。而 Node.js 的出现，使 Javascript 可以象其它编程语言一样运行在计算机上，Node.js 之于 Javascript 可以类比 JRE 之于 Java。所以 Node.js 不是一个编程语言，也不是一个 Javascript 框架，它是一整套 Javascript 的运行时环境（Runtime）。 由于 Node.js 的出现，使 Javascript 彻底摆脱浏览器成为一门独立的编程语言。和其它编程语言 Python, Java, Rube 等一样，除了本身擅长前端开发以外，Javascript 也可以开发后台、GUI程序、CLI命令行工具等等。Javascript 有庞大开发者基础，所以 Node.js 的出现使基于 Javascript 的技术栈直接井喷。 Node.js 的安装使用可以参考：Node.js Tutorial Node.js 的特点Node.js 本身的核心模块包括文件系统I/O、网络（HTTP、TCP、UDP、DNS、TLS/SSL等）、二进制数据流、加密算法、数据流等等。Node.js 模块的 API 形式简单，降低了编程的复杂度。 Node.js 的最大特点在于它基于高性能的 Chrome V8 引擎，提供了一个单线程 NIO (非阻塞队列) 的事件驱动模型。这使它极其高效和轻量级。 如上图所示，Node.js 的核心是一个事件驱动的单线程非阻塞 Event Loop 用来处理所有的请求（由于是单线程，所以不需要锁，避免了多线程带来的复杂性和开销），这样的设计让 Node.js 非常擅于 IO 密集型的应用，能够充分用效的利用硬件资源，从而提供更高的并发性能。 性能对比引用：Node.js vs Springboot: Hello world performance comparison 传统 Spring Boot 和 Node.js 的性能对比。需要说明的是这并不是一个严谨的比较，因为基于 Java 语言也有很多优秀的 NIO 模型框架，比如 Netty、以及基于 Netty 的 spring5-webflux，其提供了恐怖的并发性能。所以这个比较只是一个示例，用于说明 Node.js 在特定场景下的的优势，仅供参考。勿喷。 Node.js 的适用场景迄今为止 Node.js 发展出了一个庞大且完善的生态系统，提供了各种各样的第三方模块和工具，例如 Express、Koa、Nest 以及数不清的 Javascript Library。但传统的语言比如 Java 在生态方面一样非常强大。 从业务角度来讲 Node.js 的最大优点是易上手、开发简单速度快，Javascript 的语言特性可以让开发者以极快的速度响应不断变化的业务场景，前后端可以用同一种语言实现代码复用。另外生态强大就意味着轮子多，文档完善，有什么需求找合适的轮子直接用，提高生产效率。所以 Node.js 在开发轻量级、快速迭代、实时交互等类型的 Web 应用程序方面是有优势的。 从技术角度来讲，轻量、快速、实时的网络应用程序，例如聊天、游戏、社交等领域是 Node.js 的强项。 从资源占用方面来讲，Node.js 通常可以让你用更少的代价去高效的利用资源（CPU、Memory…），以支撑更高的访问量。 相反的，重量级、稳定可靠、安全保密等类型的 Web 应用程序，可能并不适合用 Node.js 来进行开发。但 Node.js 的社区也在不断发展，需要持续关注 Node.js 带来的可能性。","link":"/2023/03/10/nodejs-brief/"},{"title":"前端自动化测试的挑战和应对","text":"前端界面自动化测试是一种通过模拟用户操作来验证前端功能和界面的测试方法。它可以提高测试效率，减少人工干预，提升软件质量。但是，前端界面自动化测试也面临着一些挑战，比如： 前端界面变更频繁，导致测试用例失效或难以维护 前端界面涉及多种元素和交互，导致测试用例复杂或不稳定 前端界面需要适配多种浏览器和设备，导致测试用例覆盖不全或执行缓慢 针对这些挑战，有以下一些建议： 选择合适的自动化测试框架。前端自动化的流派主要分为三类：基于录制回放技术的自动化测试框架，基于对文档对象模型 (DOM）对象进行解析的自动化测试框架，以及基于图像识别的自动化测试框架。每种框架都有其优缺点和适用场景，需要根据项目的特点和需求进行选择。 优先进行单元测试和服务测试。前端项目通常UI变化频繁，一旦发生变化，UI测试用例就无法执行且难以维护，所以UI自动化测试的成本高，收益小；相比UI测试，Service测试更加简单直接且变化不会很频繁；单元测试主要对公共函数、方法进行测试，测试用例复用度高且更能保证代码质量。因此，在进行前端自动化测试时，应该优先考虑单元测试和服务测试，并尽量覆盖所有可能出现的情况。 使用云测平台或容器技术。为了解决前端界面需要适配多种浏览器和设备的问题，可以使用云测平台或容器技术来提供多样化的环境和资源，并实现并行执行、实时监控、远程调试等功能。这样可以节省本地资源、提高执行速度、增强可靠性。 那么如何编写高质量的前端自动化测试用例呢？ 编写高质量的前端自动化用例是一项重要的技能，它可以帮助你更有效地验证前端功能和界面，发现并修复缺陷，提升软件质量。根据网上的搜索结果。以下是一些编写高质量的前端自动化用例的原则和规范： 针对稳定且重要的业务基础代码编写测试用例，比如通用组件、通用算法和数据模块等，避免频繁变更的UI元素和交互。 遵循测试用例编写的统一格式，包括测试编号、测试标题、测试目标、测试步骤、预期结果、实际结果等，并使用清晰明确的语言描述。 设计合理且完备的测试数据，覆盖正常情况和异常情况，并尽量使用真实或接近真实的数据。 采用模块化和参数化的方式编写测试用例，提高复用性和可维护性，并避免硬编码和冗余代码。 使用断言或检查点来验证预期结果是否与实际结果一致，并在出现错误时及时报告并记录日志。 定期执行回归测试，并根据产品需求或代码变更及时更新或删除无效或过时的测试用例。 自动化测试工具： 前端自动化测试工具有很多种，根据网上的搜索结果，我为你总结了以下一些常用的前端自动化测试工具： Karma：一个测试运行平台，可以在多个真实浏览器中运行测试用例，并提供实时反馈。它可以集成多种测试框架（如Jasmine、Mocha等）和断言库（如Chai、Sinon等），并支持代码覆盖率报告和持续集成。 Jest：一个基于Jasmine的JavaScript测试框架，可以对React、Vue等前端框架进行单元测试和快照测试。它内置了断言库、模拟库、代码覆盖率工具等功能，并提供了简洁的API和快速的执行速度。 Selenium：一个用于Web应用程序自动化测试的工具，可以模拟用户在浏览器中的操作，并验证预期结果。它支持多种编程语言（如Java、Python、Ruby等）和浏览器（如Chrome、Firefox、IE等），并提供了WebDriver API和IDE插件。 Cypress：一个全新的前端自动化测试框架，可以对Web应用程序进行端到端的集成测试。它不需要依赖Selenium或其他外部服务，而是直接运行在浏览器中，并提供了丰富的API和图形界面。 引用： 常用的前端自动化测试工具介绍 —— Karma_前端江太公的博客-CSDN博客_前端自动化测试工具. https://blog.csdn.net/ZiChen_Jiang/article/details/122130962 访问时间 2023/3/16. 前端自动化测试jest - 冷风风 - 博客园. https://www.cnblogs.com/miangao/p/17219585.html 访问时间 2023/3/16. web 前端的自动化测试工具都有哪些？ - 知乎. https://www.zhihu.com/question/483900495 访问时间 2023/3/16. 前端自动化测试框架cypress - 掘金. https://juejin.cn/post/7051405917832609828 访问时间 2023/3/16. 前端自动化测试-Jest 快速入门 - 掘金. https://juejin.cn/post/6974673792748486693 访问时间 2023/3/16. 如何进行前端自动化测试？ - 知乎. https://www.zhihu.com/question/29922082 访问时间 2023/3/16. 测试用例编写规范 - 知乎. https://zhuanlan.zhihu.com/p/144846636 访问时间 2023/3/16. 字节测试总监，让我们用这份《测试用例规范》，再也没加班过 - 掘金. https://juejin.cn/post/7210299613974020154 访问时间 2023/3/16. 种前端自动化测试框架，到底谁是No.1 - 知乎. https://zhuanlan.zhihu.com/p/468599846 访问时间 2023/3/16. 前端自动化测试详解 - 知乎. https://zhuanlan.zhihu.com/p/84405914 访问时间 2023/3/16. 如何进行前端自动化测试？ - 知乎. https://www.zhihu.com/question/29922082 访问时间 2023/3/16. 一文搞定前端自动化测试（Vue 实战） - 掘金. https://juejin.cn/post/6973227219074154503 访问时间 2023/3/16.","link":"/2023/03/16/fe-auto-testing/"},{"title":"React Hooks","text":"[toc] Reactjs是一个用于构建用户界面的JavaScript库，它提供了一种称为Hooks的特性，让你可以在函数组件中使用状态和其他React特性，而不需要写类组件。 Reactjs提供了以下几种HooksuseState useState: 用于在函数组件中添加状态。它返回一个状态变量和一个更新该变量的函数。你可以在组件中多次使用useState来定义多个状态变量。 useEffect useEffect: 用于在函数组件中执行副作用，如数据获取、订阅、定时器等。它接受一个函数作为参数，该函数会在每次渲染后执行。你可以在组件中多次使用useEffect来定义多个副作用。 useContext useContext：用于在函数组件中访问React的上下文。它接受一个上下文对象作为参数，并返回该上下文的当前值。你可以使用useContext来避免通过多层组件传递props。 useReducer useReducer：用于在函数组件中管理复杂的状态逻辑。它接受一个reducer函数和一个初始状态作为参数，并返回一个当前状态和一个分发action的函数。你可以使用useReducer来替代useState，当你的状态逻辑包含多个子值或者依赖于之前的状态时。 useCallback useCallback：用于在函数组件中缓存函数。它接受一个内联函数和一个依赖数组作为参数，并返回该函数的缓存版本。你可以使用useCallback来避免不必要的重新渲染，当你把函数作为props传递给子组件时。 useMemo useMemo：用于在函数组件中缓存计算结果。它接受一个创建值的函数和一个依赖数组作为参数，并返回该值的缓存版本。你可以使用useMemo来避免重复计算，当你的计算结果依赖于一些变化较少的值时。 useRef useRef: 用于在函数组件中创建可变的引用对象。它接受一个初始值作为参数，并返回一个包含当前值属性（.current) 的对象。你可以使用useRef来保存任何可变值，而不会触发重新渲染，例如DOM元素、定时器ID等。 useImperativeHandle useImperativeHandle: 用于在自定义Hook中自定义暴露给父组件的ref对象。它接受一个ref对象和一个创建ref对象当前值属性（.current) 的回调函数作为参数，并将回调函数返回的结果分配给ref对象当前值属性（.current) 。你可以使用useImperativeHandle来控制父组件通过ref访问子组件实例时能够访问到什么内容。 useLayoutEffect useLayoutEffect: 与useEffect类似，但是会在所有DOM更改之后同步执行副作用回调，在浏览器绘制之前执行回调，在大多数情况下应该优先使用useEffect，除非需要从DOM读取布局并同步触发更新，在这种情况下应该使用useLayoutEffect useDebugValue useDebugValue: 可以被自定义Hook开发者使用，在 React DevTools 中显示自定义hook标签。 好的，我可以给你一些使用Hooks的示例代码，但是请注意，这些代码只是为了演示Hooks的用法，并不一定代表最佳实践。如果你想要更深入地学习Hooks，请参考React官方文档¹²或者其他可靠的资源。 以下是一些使用Hooks的示例代码useState12345678910111213141516171819202122232425import React, { useState } from &quot;react&quot;;function Counter() { // 定义一个名为count的状态变量，初始值为0 const [count, setCount] = useState(0); // 定义一个函数，用于增加count的值 function increment() { setCount(count + 1); } // 定义一个函数，用于减少count的值 function decrement() { setCount(count - 1); } // 返回一个JSX元素，显示count的值和两个按钮 return ( &lt;div&gt; &lt;p&gt;当前计数：{count}&lt;/p&gt; &lt;button onClick={increment}&gt;+1&lt;/button&gt; &lt;button onClick={decrement}&gt;-1&lt;/button&gt; &lt;/div&gt; );} useEffect12345678910111213141516171819202122import React, { useEffect, useState } from &quot;react&quot;;function Clock() { // 定义一个名为time的状态变量，初始值为当前时间 const [time, setTime] = useState(new Date()); // 使用useEffect定义一个副作用，每隔一秒更新time的值 useEffect(() =&gt; { // 创建一个定时器ID const timerID = setInterval(() =&gt; { setTime(new Date()); }, 1000); // 返回一个清理函数，在组件卸载时取消定时器 return () =&gt; { clearInterval(timerID); }; }, []); // 空数组表示只在组件挂载时执行一次 // 返回一个JSX元素，显示当前时间 return &lt;p&gt;现在是：{time.toLocaleTimeString()}&lt;/p&gt;;} useReducer123456789101112131415161718192021222324252627import React, { useReducer } from &quot;react&quot;;// 定义一个reducer函数，根据action的类型更新statefunction reducer(state, action) { switch (action.type) { case &quot;increment&quot;: return { count: state.count + 1 }; case &quot;decrement&quot;: return { count: state.count - 1 }; default: throw new Error(); }}function Counter() { // 使用useReducer定义一个名为state的状态变量和一个名为dispatch的函数，初始值为{count:0} const [state, dispatch] = useReducer(reducer, { count: 0 }); // 返回一个JSX元素，显示state.count的值和两个按钮 return ( &lt;div&gt; &lt;p&gt;当前计数：{state.count}&lt;/p&gt; &lt;button onClick={() =&gt; dispatch({ type: &quot;increment&quot; })}&gt;+1&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({ type: &quot;decrement&quot; })}&gt;-1&lt;/button&gt; &lt;/div&gt; );} 好的，我可以再给你一些useCallback和useContext的示例代码，但是请注意，这些代码只是为了演示Hooks的用法，并不一定代表最佳实践。如果你想要更深入地学习Hooks，请参考React官方文档¹²³或者其他可靠的资源。 以下是一些useCallback和useContext的示例代码： useCallback123456789101112131415161718192021222324import React, { useCallback, useState } from &quot;react&quot;;function Child({ increment }) { // 返回一个JSX元素，显示一个按钮 return &lt;button onClick={increment}&gt;+1&lt;/button&gt;;}function Parent() { // 定义一个名为count的状态变量，初始值为0 const [count, setCount] = useState(0); // 使用useCallback定义一个函数，用于增加count的值，并将count作为依赖项 const increment = useCallback(() =&gt; { setCount((prevCount) =&gt; prevCount + 1); }, [count]); // 返回一个JSX元素，显示count的值和Child组件 return ( &lt;div&gt; &lt;p&gt;当前计数：{count}&lt;/p&gt; &lt;Child increment={increment} /&gt; &lt;/div&gt; );} useContext123456789101112131415161718192021222324252627import React, { useContext } from &quot;react&quot;;// 创建一个名为ThemeContext的上下文对象，并设置默认值为lightconst ThemeContext = React.createContext(&quot;light&quot;);function App() { // 定义一个名为theme的状态变量，初始值为dark const [theme, setTheme] = React.useState(&quot;dark&quot;); // 定义一个函数，用于切换theme的值 function toggleTheme() { setTheme((prevTheme) =&gt; (prevTheme === &quot;dark&quot; ? &quot;light&quot; : &quot;dark&quot;)); } // 返回一个JSX元素，使用ThemeContext.Provider包裹子组件，并传递theme作为value属性 return ( &lt;ThemeContext.Provider value={theme}&gt; &lt;div&gt; &lt;p&gt;当前主题：{theme}&lt;/p&gt; &lt;button onClick={toggleTheme}&gt;切换主题&lt;/button&gt; &lt;Toolbar /&gt; &lt;/div&gt; &lt;/ThemeContext.Provider&gt; );}function Toolbar() { useContext • React. https://beta.reactjs.org/reference/react/useContext 访问时间 2023/3/16. React useContext Hook Tutorial (with Examples) - Dave Ceddia. https://daveceddia.com/usecontext-hook/ 访问时间 2023/3/16. React useContext Hook - W3Schools. https://www.w3schools.com/react/react_usecontext.asp 访问时间 2023/3/16.源: 与必应的对话， 2023/3/16(1) Hooks API Reference – React. https://reactjs.org/docs/hooks-reference.html 访问时间 2023/3/16. useContext • React. https://beta.reactjs.org/reference/react/useContext 访问时间 2023/3/16. useCallback • React. https://beta.reactjs.org/reference/react/useCallback 访问时间 2023/3/16.源: 与必应的对话， 2023/3/16(1) Introducing Hooks – React. https://reactjs.org/docs/hooks-intro.html 访问时间 2023/3/16. Hooks at a Glance – React. https://reactjs.org/docs/hooks-overview.html 访问时间 2023/3/16. Using the State Hook – React. https://reactjs.org/docs/hooks-state.html 访问时间 2023/3/16. Introducing Hooks – React. https://reactjs.org/docs/hooks-intro.html 访问时间 2023/3/16. Hooks at a Glance – React. https://reactjs.org/docs/hooks-overview.html 访问时间 2023/3/16. 11 Useful Custom React Hooks for Your Next Web App. https://blog.bitsrc.io/11-useful-custom-react-hooks-for-your-next-app-c66307cf0f0c 访问时间 2023/3/16. Un vistazo a los Hooks – React. https://es.reactjs.org/docs/hooks-overview.html 访问时间 2023/3/16. Presentando Hooks – React. https://es.reactjs.org/docs/hooks-intro.html 访问时间 2023/3/16. Introducing Hooks – React. https://reactjs.org/docs/hooks-intro.html 访问时间 2023/3/16. React Hooks - W3Schools. https://www.w3schools.com/react/react_hooks.asp 访问时间 2023/3/16. Hooks API Reference – React. https://reactjs.org/docs/hooks-reference.html 访问时间 2023/3/16.","link":"/2023/03/16/react-hooks/"}],"tags":[],"categories":[],"pages":[]}